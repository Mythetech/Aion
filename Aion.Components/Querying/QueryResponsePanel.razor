@using System.Text.Json.Nodes
@using Mythetech.Framework.Infrastructure.MessageBus
@using Aion.Components.Querying.Commands
@using Aion.Components.Querying.Consumers
@using Aion.Components.Querying.Editing
@using Aion.Components.RequestContextPanel
@using Aion.Components.RequestContextPanel.Commands
@using Aion.Components.Shared
@using Aion.Components.Theme
@using Aion.Core.Queries
@using Aion.Core.Queries.Editing
@using Aion.Components.Shared.Loaders
@using Aion.Components.Querying
@implements IDisposable

@if (State?.Active?.Result != null && (!State?.Active?.IsExecuting ?? false))
{
    QueryResult queryResult = State.Active.Result;
    <MudStack Class="pa-4 h-100 w-100">
        <MudStack Row="true" Class="w-100">
            <MudTabs Class="py-2 px-1" MinimumTabWidth="140px">
                <MudTabPanel Text="Results" OnClick="() => _activeTab = Results" />
                <MudTabPanel Text="Messages" OnClick="() => _activeTab = Messages" />
                @if (State.Active.EstimatedPlan != null)
                {
                    <MudTabPanel Text="Estimated Plan" OnClick="() => _activeTab = EstimatedPlan" />
                }
                @if (State.Active.ActualPlan != null)
                {
                    <MudTabPanel Text="Actual Plan" OnClick="() => _activeTab = ActualPlan" />
                }
                @if (State.Active.EditMetadata?.IsEditMode == true)
                {
                    <MudTabPanel Text="Edit" Icon="@Icons.Material.Filled.Edit" OnClick="() => _activeTab = Edit" />
                }
            </MudTabs>
            <MudSpacer />
            <MudTextField
                T="string"
                @bind-Value="@_search"
                Class="rounded-xl"
                Variant="Variant.Text"
                Margin="Margin.Dense"
                Clearable="true"
                Immediate="true"
                AdornmentIcon="@AionIcons.Filter"
                Adornment="Adornment.End"
                Placeholder="Find in results..." />
            <MudSpacer />
            @if (_selectionState.HasSelection)
            {
                <MudChip T="string" Size="Size.Small" Color="Color.Primary" Variant="Variant.Outlined">
                    @_selectionState.SelectedCount selected
                </MudChip>
            }
            <AionIconButton Icon="@AionIcons.Json" Tooltip="Export to Json" OnClick="async () => await Bus.PublishAsync(new ExportResultsToJson(queryResult))" />
            <AionIconButton Icon="@AionIcons.Csv" Tooltip="Export to Csv" OnClick="async () => await Bus.PublishAsync(new ExportResultsToCsv(queryResult))" />
            <AionIconButton Icon="@AionIcons.Spreadsheet" Tooltip="Export to Excel" OnClick="async () => await Bus.PublishAsync(new ExportResultsToExcel(queryResult))" />
        </MudStack>
        @if (_activeTab == Results)
        {
            <MudStack Class="h-100 w-100 overflow-auto flex-shrink-1">
                <QueryResultTable Result="@State.Active.Result"
                                  QueryName="@State.Active.Name"
                                  SearchFilter="@_search"
                                  SelectionState="@_selectionState"
                                  EditState="@GetOrCreateEditState()"
                                  EditMetadata="@State.Active.EditMetadata" />
            </MudStack>
        }
        else if (_activeTab == Messages)
        {
            <MudText>@State.Active.Result.Error</MudText>
        }
        else if (_activeTab == EstimatedPlan)
        {
            <QueryPlanVisualizer Plan="@State.Active.EstimatedPlan" />
        }
        else if (_activeTab == ActualPlan)
        {
            <QueryPlanVisualizer Plan="@State.Active.ActualPlan" />
        }
        else if (_activeTab == Edit && State.Active.EditMetadata?.IsEditMode == true)
        {
            var editState = GetOrCreateEditState();
            @if (editState != null)
            {
                <PendingChangesPanel
                    EditState="@editState"
                    EditableResult="@GetEditableResult()"
                    OnApplyChanges="@ApplyChanges"
                    OnDiscardChanges="@DiscardChanges"
                    OnExitEditMode="@ExitEditMode" />
            }
        }
        <MudStack Row="true" AlignItems="AlignItems.Center">
            <MudText Typo="Typo.caption" Class="mud-text-secondary ml-4">
                @(State?.Active?.Result?.RowCount ?? 0) Results
            </MudText>
            <MudDivider Vertical="true" />
            <QueryTimer StartTime="@State.Active.ExecutionStartTime" EndTime="@State.Active.ExecutionEndTime" Typo="Typo.caption" />
        </MudStack>
    </MudStack>
}
else if (State?.Active?.IsExecuting ?? false)
{
    <MudStack AlignItems="AlignItems.Center" Justify="Justify.Center" Spacing="3" Class="h-100">
        <MudSkeleton Width="100%" Height="97%" SkeletonType="SkeletonType.Rectangle" Style="position:absolute;" Class="ml-8" Animation="Animation.Wave"/>
        <WaveLoader />
        <LoadingText Text="Running Query" />
        <QueryTimer StartTime="@State.Active.ExecutionStartTime" EndTime="@State.Active.ExecutionEndTime" />
    </MudStack>
}



@code {
    [Inject] protected QueryState State { get; set; } = default!;
    [Inject] protected IMessageBus Bus { get; set; } = default!;

    private string? _search = "";
    private const string Results = "results";
    private const string Edit = "edit";
    private string Messages => "messages";
    private string EstimatedPlan => "estimated";
    private string ActualPlan => "actual";

    private string _activeTab = Results;
    private RowSelectionState _selectionState = new();
    private Dictionary<Guid, EditState> _editStates = new();

    [Parameter] public QueryPlan? QueryPlan { get; set; }

    protected override void OnInitialized()
    {
        State.StateChanged += OnStateChanged;
        _selectionState.SelectionChanged += StateHasChanged;
        base.OnInitialized();
    }

    private void OnStateChanged()
    {
        // Clear selection when switching queries or when results change
        _selectionState.ClearSelection();
        StateHasChanged();
    }

    // EditState management per query
    private EditState? GetOrCreateEditState()
    {
        if (State.Active?.EditMetadata?.IsEditMode != true) return null;

        var queryId = State.Active.Id;
        if (!_editStates.TryGetValue(queryId, out var editState))
        {
            editState = new EditState { IsEditMode = true };
            _editStates[queryId] = editState;
        }
        return editState;
    }

    private EditableQueryResult? GetEditableResult()
    {
        if (State.Active?.Result == null || State.Active.EditMetadata == null) return null;
        return EditableQueryResult.FromQueryResult(
            State.Active.Result,
            State.Active.EditMetadata.SourceTable,
            State.Active.EditMetadata.SourceDatabase,
            State.Active.ConnectionId,
            State.Active.EditMetadata.ColumnMetadata);
    }

    private async Task ApplyChanges()
    {
        var editState = GetOrCreateEditState();
        var editableResult = GetEditableResult();
        if (editState != null && editableResult != null)
        {
            await Bus.PublishAsync(new ApplyPendingChanges(editState, editableResult));

            // If changes were cleared (success), exit edit mode
            // The consumer clears changes on success
            if (!editState.HasChanges)
            {
                ExitEditMode();
            }
        }
    }

    private void DiscardChanges()
    {
        GetOrCreateEditState()?.DiscardAllChanges();
    }

    private void ExitEditMode()
    {
        if (State.Active == null) return;

        // Clear the edit state for this query
        _editStates.Remove(State.Active.Id);

        // Clear edit metadata to exit edit mode
        State.Active.EditMetadata = null;

        // Switch back to Results tab
        _activeTab = Results;

        StateHasChanged();
    }

    public void Dispose()
    {
        State.StateChanged -= OnStateChanged;
        _selectionState.SelectionChanged -= StateHasChanged;
    }
}